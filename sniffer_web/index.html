<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MClaudia Sniffer</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #00ff00;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #2a2a2a;
            border-radius: 5px;
        }
        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button {
            padding: 8px 16px;
            background-color: #333;
            color: #00ff00;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background-color: #444;
        }
        button:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
        .status.connected {
            background-color: #004400;
            color: #00ff00;
        }
        .status.disconnected {
            background-color: #440000;
            color: #ff0000;
        }
        .main-content {
            display: flex;
            gap: 20px;
        }
        .packet-list {
            flex: 2;
            background-color: #2a2a2a;
            border-radius: 5px;
            padding: 10px;
            max-height: 600px;
            overflow-y: auto;
        }
        .packet-item {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #333;
            border-radius: 3px;
            border-left: 3px solid #555;
            cursor: pointer;
            transition: all 0.2s;
        }
        .packet-item:hover {
            background-color: #444;
            border-left-color: #00ff00;
        }
        .packet-item.rx {
            border-left-color: #00aa00;
        }
        .packet-item.tx {
            border-left-color: #0088ff;
        }
        .packet-item.raw {
            border-left-color: #ff8800;
        }
        .packet-item.selected {
            background-color: #444;
            border-left-color: #00ff00;
            border: 2px solid #00ff00;
        }
        .packet-header {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .packet-details {
            font-size: 0.9em;
            color: #aaa;
        }
        .packet-bytes {
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            color: #888;
            word-break: break-all;
        }
        .sidebar {
            flex: 1;
            background-color: #2a2a2a;
            border-radius: 5px;
            padding: 15px;
            max-height: 100vh;
            overflow-y: auto;
        }
        .stats-section {
            margin-bottom: 20px;
        }
        .stats-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff00;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding: 2px 0;
        }
        .filters {
            margin-bottom: 20px;
        }
        .filter-group {
            margin-bottom: 10px;
        }
        .filter-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
        }
        .filter-group select, .filter-group input {
            width: 100%;
            padding: 5px;
            background-color: #333;
            color: #00ff00;
            border: 1px solid #555;
            border-radius: 3px;
            font-family: inherit;
        }
        .packet-detail {
            background-color: #1a1a1a;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00ff00;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        .detail-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .close-button {
            background: none;
            border: none;
            color: #ff6666;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        .close-button:hover {
            background-color: #ff6666;
            color: #333;
        }
        .detail-content {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>MClaudia Sniffer</h1>
            <div class="controls">
                <button id="connectBtn">Connect</button>
                <button id="disconnectBtn" disabled>Disconnect</button>
                <button id="clearBtn">Clear</button>
                <div class="status disconnected" id="status">Disconnected</div>
            </div>
        </div>

        <div class="main-content">
            <div class="packet-list">
                <div id="packetContainer">
                    <div style="text-align: center; color: #666; padding: 20px;">
                        Connect to sniffer node to see packets...
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="stats-section">
                    <div class="stats-title">Statistics</div>
                    <div class="stat-item">
                        <span>Total Packets:</span>
                        <span id="totalPackets">0</span>
                    </div>
                </div>

                <div class="stats-section">
                    <div class="stats-title">Known Channels</div>
                    <div id="channels-content">
                    </div>
                    <div style="margin-top: 10px;">
                        <input type="text" id="new-channel-hash" placeholder="Channel hash (0xXX)" style="width: 60%; font-size: 0.8em; padding: 2px;">
                        <input type="text" id="new-channel-name" placeholder="Name" style="width: 25%; font-size: 0.8em; padding: 2px;">
                        <button onclick="addKnownChannel()" style="width: 12%; font-size: 0.7em; padding: 2px;">Add</button>
                    </div>
                    <div style="margin-top: 5px; display: flex; gap: 5px;">
                        <button onclick="exportChannels()" style="font-size: 0.7em; padding: 2px 4px; flex: 1;">Export</button>
                        <button onclick="importChannels()" style="font-size: 0.7em; padding: 2px 4px; flex: 1;">Import</button>
                        <input type="file" id="channel-file-input" accept=".json" style="display: none;" onchange="handleChannelFileImport(event)">
                    </div>
                </div>

                <div class="filters">
                    <div class="stats-title">
                        Filters
                        <span id="clearFiltersIndicator" style="display: none; color: #ff6666; font-size: 0.8em; margin-left: 10px; cursor: pointer;" onclick="clearAllFilters()">
                            Clear filters Ã—
                        </span>
                    </div>
                    <div class="filter-group">
                        <label>Payload Type:</label>
                        <select id="payloadFilter">
                            <option value="">All</option>
                            <option value="0">REQ</option>
                            <option value="1">RESPONSE</option>
                            <option value="2">TXT_MSG</option>
                            <option value="3">ACK</option>
                            <option value="4">ADVERT</option>
                            <option value="5">GRP_TXT</option>
                            <option value="6">GRP_DATA</option>
                            <option value="7">ANON_REQ</option>
                            <option value="8">PATH</option>
                            <option value="9">TRACE</option>
                            <option value="10">MULTIPART</option>
                            <option value="11">RAW_CUSTOM</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Route Type:</label>
                        <select id="routeFilter">
                            <option value="">All</option>
                            <option value="TRANSPORT_FLOOD">TRANSPORT_FLOOD</option>
                            <option value="FLOOD">FLOOD</option>
                            <option value="DIRECT">DIRECT</option>
                            <option value="TRANSPORT_DIRECT">TRANSPORT_DIRECT</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Hop Count:</label>
                        <input type="number" id="hopFilter" min="0" max="64" placeholder="All hops" style="width: 100%; padding: 5px; background-color: #333; color: #00ff00; border: 1px solid #555; border-radius: 3px; font-family: inherit;">
                    </div>
                </div>

                <div class="packet-detail" id="packetDetail" style="display: none;">
                    <div class="detail-title">
                        <span>Packet Details</span>
                        <button class="close-button" onclick="closePacketDetail(); event.stopPropagation();">&times;</button>
                    </div>
                    <div class="detail-content" id="detailContent"></div>
                </div>
            </div>
        </div>
    </div>

    <div style="margin-top: 20px; padding: 15px; background-color: #2a2a2a; border-radius: 5px;">
        <h3 style="color: #00ff00; margin-bottom: 15px;">Packet Statistics</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
            
            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Packet Types</h4>
                <div id="packet-types-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Channel Activity</h4>
                <div id="channel-stats-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Routing Types</h4>
                <div id="routing-stats-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Path Lengths</h4>
                <div id="path-stats-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">First Hops (Repeaters)</h4>
                <div id="first-hops-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Sender Hashes</h4>
                <div id="sender-hashes-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Destination Hashes</h4>
                <div id="destination-hashes-table" style="font-size: 0.9em;">
                </div>
            </div>

            <div>
                <h4 style="color: #ffffff; margin-bottom: 10px;">Communication Pairs</h4>
                <div id="communication-pairs-table" style="font-size: 0.9em;">
                </div>
            </div>

        </div>
    </div>

    <script src="raw_packet_parser.js"></script>
    <script>
        let port = null;
        let reader = null;
        let parser = new RawPacketParser();
        let selectedPacket = null;
        let serialBuffer = '';

        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const clearBtn = document.getElementById('clearBtn');
        const status = document.getElementById('status');
        const packetContainer = document.getElementById('packetContainer');
        const packetDetail = document.getElementById('packetDetail');
        const detailContent = document.getElementById('detailContent');
        const payloadFilter = document.getElementById('payloadFilter');
        const routeFilter = document.getElementById('routeFilter');
        const hopFilter = document.getElementById('hopFilter');

        const totalPackets = document.getElementById('totalPackets');
        const getById = document.getElementById.bind(document);

        connectBtn.addEventListener('click', connect);
        disconnectBtn.addEventListener('click', disconnect);
        clearBtn.addEventListener('click', clearPackets);
        payloadFilter.addEventListener('change', () => {
            applyFilters();
            saveFilterSettings();
        });
        routeFilter.addEventListener('change', () => {
            applyFilters();
            saveFilterSettings();
        });
        hopFilter.addEventListener('input', () => {
            applyFilters();
            saveFilterSettings();
        });

        document.addEventListener('click', function(event) {
            const clickedPacket = event.target.closest('.packet-item');
            const clickedPacketDetail = event.target.closest('#packetDetail');
            const clickedClearBtn = event.target.closest('#clearBtn');
            
            if (!clickedPacket && !clickedPacketDetail && selectedPacket) {
                selectedPacket = null;
                packetDetail.style.display = 'none';
                renderPackets();
            }
            
            if (!clickedClearBtn) {
                resetClearButton();
            }
        });

        async function connect() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                
                status.textContent = 'Connected';
                status.className = 'status connected';
                connectBtn.textContent = "Sniffin'...";
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                
                reader = port.readable.getReader();
                readData();
            } catch (err) {
                alert('Failed to connect: ' + err.message);
            }
        }

        async function disconnect() {
            if (reader) {
                await reader.cancel();
                reader = null;
            }
            if (port) {
                await port.close();
                port = null;
            }
            
            serialBuffer = '';
            status.textContent = 'Disconnected';
            status.className = 'status disconnected';
            connectBtn.textContent = 'Connect';
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
        }

        async function readData() {
            try {
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const text = new TextDecoder().decode(value);
                    serialBuffer += text;
                    
                    const lines = serialBuffer.split('\n');
                    serialBuffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        const cleanLine = line.trim();
                        if (cleanLine) {
                            const rawIndex = cleanLine.indexOf('RAW|');
                            if (rawIndex !== -1) {
                                   const rawPacket = cleanLine.substring(rawIndex);
                                   const packet = await parser.parseLine(rawPacket);
                                   if (packet) {
                                       updateDisplay();
                                   }
                            }
                        }
                    }
                }
               } catch (err) {
                   disconnect();
               }
        }

        function updateDisplay() {
            updateStats();
            renderPackets();
            updateStatisticsTables();
        }

        function updateStats() {
            const filter = {
                payloadType: payloadFilter.value && payloadFilter.value !== '' ? parseInt(payloadFilter.value) : undefined,
                routeType: routeFilter.value && routeFilter.value !== '' ? routeFilter.value : undefined,
                hopCount: hopFilter.value && hopFilter.value !== '' ? parseInt(hopFilter.value) : undefined
            };
            
            const stats = parser.getStats(filter);
            totalPackets.textContent = stats.total;
            
        }

        function renderPackets() {
            const filter = {
                payloadType: payloadFilter.value && payloadFilter.value !== '' ? parseInt(payloadFilter.value) : undefined,
                routeType: routeFilter.value && routeFilter.value !== '' ? routeFilter.value : undefined,
                hopCount: hopFilter.value && hopFilter.value !== '' ? parseInt(hopFilter.value) : undefined
            };
            
            const packets = parser.getPackets(filter);
            const recentPackets = packets.slice(-100).reverse();
            
            packetContainer.innerHTML = '';
            
            if (recentPackets.length === 0) {
                packetContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No packets matching filters...</div>';
                return;
            }
            
            recentPackets.forEach(packet => {
                const packetEl = createPacketElement(packet);
                packetContainer.appendChild(packetEl);
            });
            
        }

        function resetClearButton() {
            const clearBtn = getById('clearBtn');
            if (clearBtn.textContent === 'Are you sure?') {
                clearBtn.textContent = 'Clear';
                clearBtn.style.backgroundColor = '';
            }
        }


        function createPacketElement(packet) {
            const div = document.createElement('div');
            div.className = `packet-item ${packet.type.toLowerCase()}`;
            
            if (selectedPacket && selectedPacket.timestamp === packet.timestamp && selectedPacket.rawHex === packet.rawHex) {
                div.classList.add('selected');
            }
            
            const timeStr = formatTimestamp(packet.timestamp);
            const typeInfo = packet.type || 'Unknown';
            
            let pathInfo = '';
            if (packet.path && packet.path.length > 0) {
                pathInfo = ` | Path: ${packet.path.join(',').toLowerCase()}`;
            } else if (packet.pathLen === 0) {
                pathInfo = ` | Path: Direct`;
            }
            
               div.innerHTML = `
                   <div class="packet-header">
                       <span>#${parser.packets.indexOf(packet) + 1} ${packet.type}</span>
                       <span>${timeStr}</span>
                   </div>
                   <div class="packet-details">
                       ${typeInfo} | Len: ${packet.length}${pathInfo}
                       ${packet.snr ? ` | SNR: ${packet.snr}dB` : ''}
                       ${packet.rssi ? ` | RSSI: ${packet.rssi}dBm` : ''}
                       ${packet.senderHash ? ` | Src: 0x${packet.senderHash}` : ''}
                       ${packet.destinationHash ? ` | Dst: 0x${packet.destinationHash}` : ''}
                   </div>
               `;
            
            div.addEventListener('click', (event) => {
                event.stopPropagation();
                selectPacket(packet);
            });
            
            return div;
        }

        function closePacketDetail() {
            packetDetail.style.display = 'none';
        }

        function selectPacket(packet) {
            if (selectedPacket === packet) {
                selectedPacket = null;
                renderPackets();
                closePacketDetail();
                return;
            }
            
            selectedPacket = packet;
            packetDetail.style.display = 'block';
            renderPackets();
            
            let detail = `Type: ${packet.type}\n`;
            detail += `Timestamp: ${formatTimestamp(packet.timestamp)}\n`;
            if (packet.packetTimestamp) {
                const packetDate = new Date(packet.packetTimestamp * 1000);
                detail += `Packet Timestamp: ${packet.packetTimestamp} (${packetDate.toISOString()})\n`;
            }
            detail += `Length: ${packet.length} bytes\n`;
            detail += `SNR: ${packet.snr} dB\n`;
            detail += `RSSI: ${packet.rssi} dBm\n`;
            detail += `Route Type: ${packet.routeType || 'Unknown'}\n`;
            detail += `Payload Type: ${packet.payloadType || 'Unknown'}\n`;
            detail += `Payload Version: ${packet.payloadVersion !== undefined ? (packet.payloadVersion + 1) : 'Unknown'}\n`;
            detail += `Path Length: ${packet.pathLen || 0} hops\n`;
            
            // Sender/Destination info
            if (packet.senderHash || packet.destinationHash || packet.senderPublicKey || packet.ephemeralPublicKey) {
                detail += `\n--- Sender/Destination Information ---\n`;
                
                if (packet.senderHash) {
                    detail += `Sender Hash: 0x${packet.senderHash} (first byte of sender's public key)\n`;
                }
                if (packet.destinationHash) {
                    detail += `Destination Hash: 0x${packet.destinationHash} (first byte of destination's public key)\n`;
                }
                if (packet.senderPublicKey) {
                    detail += `Sender Public Key: ${packet.senderPublicKey}\n`;
                }
                if (packet.ephemeralPublicKey) {
                    detail += `Ephemeral Public Key: ${packet.ephemeralPublicKey}\n`;
                }
            }
            
            if (packet.channelName && packet.channelName !== 'Unknown') {
                detail += `Channel: ${packet.channelName} (0x${packet.channelHash.toString(16).toUpperCase()})\n`;
            } else if (packet.channelHash !== null) {
                detail += `Channel: Unknown (0x${packet.channelHash.toString(16).toUpperCase()})\n`;
            }
            
            if (packet.path && packet.path.length > 0) {
                detail += `Path: ${packet.path.join(',').toLowerCase()} (${packet.pathLen} hops)\n`;
            } else if (packet.pathLen === 0) {
                detail += `Path: Direct (0 hops)\n`;
            } else {
                detail += `Path: Unknown (${packet.pathLen} hops)\n`;
            }
            
            // Additional info
            if (packet.additionalInfo) {
                const info = packet.additionalInfo;
                if (info.transportCodes) {
                    detail += `Transport Codes: [${info.transportCodes[0]}, ${info.transportCodes[1]}]\n`;
                }
                if (info.mac) {
                    detail += `MAC: ${Array.from(info.mac).map(b => b.toString(16).toUpperCase().padStart(2, '0')).join('')}\n`;
                }
                if (info.ciphertextLen !== undefined) {
                    detail += `Ciphertext Length: ${info.ciphertextLen} bytes\n`;
                }
                if (info.checksum !== undefined) {
                    detail += `Checksum: 0x${info.checksum.toString(16).toUpperCase()}\n`;
                }
                if (info.location) {
                    detail += `Location: ${info.location.lat.toFixed(6)}, ${info.location.lon.toFixed(6)}\n`;
                }
                if (info.nodeName) {
                    detail += `Node Name: ${info.nodeName}\n`;
                }
                if (info.appdataFlags !== undefined) {
                    detail += `Appdata Flags: 0x${info.appdataFlags.toString(16).toUpperCase()}\n`;
                }
                if (info.feature1 !== undefined) {
                    detail += `Feature 1: 0x${info.feature1.toString(16).toUpperCase()}\n`;
                }
                if (info.feature2 !== undefined) {
                    detail += `Feature 2: 0x${info.feature2.toString(16).toUpperCase()}\n`;
                }
            }
            
            detail += `\nRaw Bytes (${packet.rawBytes.length}):\n`;
            detail += packet.rawHex.match(/.{1,32}/g).join('\n');
            
            detailContent.textContent = detail;
        }

        function applyFilters() {
            updateDisplay();
            updateClearFiltersIndicator();
        }

        function updateClearFiltersIndicator() {
            const hasFilters = payloadFilter.value || routeFilter.value || hopFilter.value;
            const indicator = document.getElementById('clearFiltersIndicator');
            indicator.style.display = hasFilters ? 'inline' : 'none';
        }

        function clearAllFilters() {
            payloadFilter.value = '';
            routeFilter.value = '';
            hopFilter.value = '';
            applyFilters();
        }

        function clearPackets() {
            const clearBtn = getById('clearBtn');
            
            if (clearBtn.textContent === 'Clear') {
                clearBtn.textContent = 'Are you sure?';
                clearBtn.style.backgroundColor = '#ff4444';
            } else {
                parser.clear();
                updateDisplay();
                packetDetail.style.display = 'none';
                selectedPacket = null;
                
                clearBtn.textContent = 'Clear';
                clearBtn.style.backgroundColor = '';
            }
        }

        function addKnownChannel() {
            const hashInput = getById('new-channel-hash').value.trim();
            const channelName = getById('new-channel-name').value.trim();
            
            if (!hashInput || !channelName) {
                alert('Please enter both channel hash and name');
                return;
            }
            
            let channelHash;
            if (hashInput.startsWith('0x') || hashInput.startsWith('0X')) {
                channelHash = parseInt(hashInput, 16);
            } else {
                channelHash = parseInt(hashInput, 16);
            }
            
            if (isNaN(channelHash) || channelHash < 0 || channelHash > 255) {
                alert('Invalid channel hash. Use hex format like "0x2F" or "2F" (0-255)');
                return;
            }
            
            parser.addChannel(channelHash, channelName);
            updateKnownChannelsDisplay();
            
            getById('new-channel-hash').value = '';
            getById('new-channel-name').value = '';
        }

        function updateKnownChannelsDisplay() {
            const channelsContent = getById('channels-content');
            
            channelsContent.innerHTML = '';
            for (const [hash, name] of Object.entries(parser.knownChannelHashes)) {
                const div = document.createElement('div');
                div.className = 'stat-item';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.style.gap = '5px';
                div.innerHTML = `
                    <input type="text" value="${name}" style="font-size: 0.8em; padding: 2px; flex: 1; background: #333; border: 1px solid #555; color: white;" onchange="editChannelName(${hash}, this.value)">
                    <span style="font-size: 0.8em; color: #888;">0x${parseInt(hash).toString(16).toUpperCase()}</span>
                    <button onclick="deleteChannel(${hash})" style="font-size: 0.6em; padding: 1px 3px; background: #ff4444; border: none; color: white; cursor: pointer;">Ã—</button>
                `;
                channelsContent.appendChild(div);
            }
        }

        function editChannelName(hash, newName) {
            if (newName.trim()) {
                parser.knownChannelHashes[hash] = newName.trim();
                parser.saveSettings();
            }
        }

        function deleteChannel(hash) {
            delete parser.knownChannelHashes[hash];
            parser.saveSettings();
            updateKnownChannelsDisplay();
        }

        function exportChannels() {
            const channels = {};
            for (const [hash, name] of Object.entries(parser.knownChannelHashes)) {
                channels[parseInt(hash).toString(16).toUpperCase()] = name;
            }
            
            const dataStr = JSON.stringify(channels, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'meshcore_channels.json';
            link.click();
        }

        function importChannels() {
            getById('channel-file-input').click();
        }

        function handleChannelFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedChannels = JSON.parse(e.target.result);
                    
                    for (const [hexHash, name] of Object.entries(importedChannels)) {
                        const numericHash = parseInt(hexHash, 16);
                        parser.knownChannelHashes[numericHash] = name;
                    }
                    
                    parser.saveSettings();
                    updateKnownChannelsDisplay();
                    alert(`Imported ${Object.keys(importedChannels).length} channels successfully!`);
                } catch (error) {
                    alert('Error importing channels: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        function updateFirstHopsTable(filter = {}) {
            const stats = parser.getStats(filter);
            const container = getById('first-hops-table');
            
            const sortedHops = Object.entries(stats.firstHops || {})
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10);
            
            if (sortedHops.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No multi-hop packets yet</div>';
                return;
            }
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="border-bottom: 1px solid #444;"><th style="text-align: left; padding: 4px;">Repeater</th><th style="text-align: right; padding: 4px;">Packets</th></tr>';
            
            sortedHops.forEach(([hop, count]) => {
                const hopHex = parseInt(hop, 16).toString(16).toUpperCase().padStart(2, '0');
                html += `<tr style="border-bottom: 1px solid #333;">`;
                html += `<td style="padding: 4px; color: #00ff00;">${hopHex}</td>`;
                html += `<td style="padding: 4px; text-align: right;">${count}</td>`;
                html += `</tr>`;
            });
            
            html += '</table>';
            container.innerHTML = html;
        }

        function updateSenderHashesTable(filter = {}) {
            const stats = parser.getStats(filter);
            const container = getById('sender-hashes-table');
            container.innerHTML = createStatsTable(stats.senderHashes, 'Sender Hash', 'Packets');
        }

        function updateDestinationHashesTable(filter = {}) {
            const stats = parser.getStats(filter);
            const container = getById('destination-hashes-table');
            container.innerHTML = createStatsTable(stats.destinationHashes, 'Destination Hash', 'Packets');
        }

        function updateCommunicationPairsTable(filter = {}) {
            const stats = parser.getStats(filter);
            const container = getById('communication-pairs-table');
            container.innerHTML = createStatsTable(stats.communicationPairs, 'Sender â†’ Destination', 'Packets');
        }

        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const seconds = date.getSeconds().toString().padStart(2, '0');
            const ms = date.getMilliseconds().toString().padStart(3, '0');
            return `${hours}:${minutes}:${seconds}.${ms}`;
        }


        function updateStatisticsTables() {
            const filter = {
                payloadType: payloadFilter.value && payloadFilter.value !== '' ? parseInt(payloadFilter.value) : undefined,
                routeType: routeFilter.value && routeFilter.value !== '' ? routeFilter.value : undefined,
                hopCount: hopFilter.value && hopFilter.value !== '' ? parseInt(hopFilter.value) : undefined
            };
            
            updatePacketTypesTable(filter);
            updateChannelStatsTable(filter);
            updateRoutingStatsTable(filter);
            updatePathStatsTable(filter);
            updateFirstHopsTable(filter);
            updateSenderHashesTable(filter);
            updateDestinationHashesTable(filter);
            updateCommunicationPairsTable(filter);
        }

        function updatePacketTypesTable(filter = {}) {
            const stats = parser.getStats(filter);
            const container = getById('packet-types-table');
            container.innerHTML = createStatsTable(stats.byType, 'Type', 'Count');
        }

       function updateChannelStatsTable(filter = {}) {
           const stats = parser.getStats(filter);
           const container = getById('channel-stats-table');
           container.innerHTML = createStatsTable(stats.byChannel, 'Channel', 'Packets');
       }

        function updateRoutingStatsTable(filter = {}) {
            const packets = parser.getPackets(filter);
            const routingCounts = {};
            
            packets.forEach(packet => {
                if (packet.routeType) {
                    routingCounts[packet.routeType] = (routingCounts[packet.routeType] || 0) + 1;
                }
            });
            
            const container = getById('routing-stats-table');
            container.innerHTML = createStatsTable(routingCounts, 'Route Type', 'Count');
        }

        function updatePathStatsTable(filter = {}) {
            const packets = parser.getPackets(filter);
            const pathCounts = {};
            
            packets.forEach(packet => {
                if (packet.pathLen !== undefined) {
                    const label = packet.pathLen === 0 ? 'Direct (0 hops)' : `${packet.pathLen} hop${packet.pathLen > 1 ? 's' : ''}`;
                    pathCounts[label] = (pathCounts[label] || 0) + 1;
                }
            });
            
            const container = getById('path-stats-table');
            container.innerHTML = createStatsTable(pathCounts, 'Path Length', 'Packets');
        }

        function createStatsTable(data, labelHeader, valueHeader) {
            const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
            
            if (entries.length === 0) {
                return '<div style="color: #888;">No data available</div>';
            }
            
            let html = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="border-bottom: 1px solid #555;">
                            <th style="text-align: left; padding: 5px; color: #00ff00;">${labelHeader}</th>
                            <th style="text-align: right; padding: 5px; color: #00ff00;">${valueHeader}</th>
                            <th style="text-align: right; padding: 5px; color: #00ff00;">%</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            const total = entries.reduce((sum, [_, count]) => sum + count, 0);
            
            entries.forEach(([label, count]) => {
                const percentage = ((count / total) * 100).toFixed(1);
                html += `
                    <tr style="border-bottom: 1px solid #333;">
                        <td style="padding: 3px; color: #fff;">${label}</td>
                        <td style="padding: 3px; text-align: right; color: #fff;">${count}</td>
                        <td style="padding: 3px; text-align: right; color: #888;">${percentage}%</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            return html;
        }

        function saveFilterSettings() {
            const settings = {
                payloadType: payloadFilter.value,
                routeType: routeFilter.value,
                hopCount: hopFilter.value
            };
            localStorage.setItem('meshcore_filter_settings', JSON.stringify(settings));
        }

        function loadFilterSettings() {
            try {
                const saved = localStorage.getItem('meshcore_filter_settings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    if (settings.payloadType) payloadFilter.value = settings.payloadType;
                    if (settings.routeType) routeFilter.value = settings.routeType;
                    if (settings.hopCount) hopFilter.value = settings.hopCount;
                }
            } catch (e) {
            }
        }

        window.addEventListener('beforeunload', () => {
            parser.saveSettings();
            saveFilterSettings();
        });

        parser.loadSettings();
        loadFilterSettings();
        updateKnownChannelsDisplay();
        updateDisplay();
        updateClearFiltersIndicator();
    </script>
</body>
</html>